/* automatically generated by rust-bindgen 0.70.1 */

pub const RTE_KVARGS_MAX: u32 = 32;
pub const RTE_KVARGS_PAIRS_DELIM: &[u8; 2] = b",\0";
pub const RTE_KVARGS_KV_DELIM: &[u8; 2] = b"=\0";
#[doc = " Callback prototype used by rte_kvargs_process().\n\n @param key\n   The key to consider, it will not be NULL.\n @param value\n   The value corresponding to the key, it may be NULL (e.g. only with key)\n @param opaque\n   An opaque pointer coming from the caller.\n @return\n   - >=0 handle key success.\n   - <0 on error."]
pub type arg_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " A key/value association"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_kvargs_pair {
    #[doc = "< the name (key) of the association"]
    pub key: *mut ::std::os::raw::c_char,
    #[doc = "< the value associated to that key"]
    pub value: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_kvargs_pair"][::std::mem::size_of::<rte_kvargs_pair>() - 16usize];
    ["Alignment of rte_kvargs_pair"][::std::mem::align_of::<rte_kvargs_pair>() - 8usize];
    ["Offset of field: rte_kvargs_pair::key"]
        [::std::mem::offset_of!(rte_kvargs_pair, key) - 0usize];
    ["Offset of field: rte_kvargs_pair::value"]
        [::std::mem::offset_of!(rte_kvargs_pair, value) - 8usize];
};
#[doc = " Store a list of key/value associations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_kvargs {
    #[doc = "< copy of the argument string"]
    pub str_: *mut ::std::os::raw::c_char,
    #[doc = "< number of entries in the list"]
    pub count: ::std::os::raw::c_uint,
    #[doc = "< list of key/values"]
    pub pairs: [rte_kvargs_pair; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_kvargs"][::std::mem::size_of::<rte_kvargs>() - 528usize];
    ["Alignment of rte_kvargs"][::std::mem::align_of::<rte_kvargs>() - 8usize];
    ["Offset of field: rte_kvargs::str_"][::std::mem::offset_of!(rte_kvargs, str_) - 0usize];
    ["Offset of field: rte_kvargs::count"][::std::mem::offset_of!(rte_kvargs, count) - 8usize];
    ["Offset of field: rte_kvargs::pairs"][::std::mem::offset_of!(rte_kvargs, pairs) - 16usize];
};
extern "C" {
    #[doc = " Allocate a rte_kvargs and store key/value associations from a string\n\n The function allocates and fills a rte_kvargs structure from a given\n string whose format is key1=value1,key2=value2,...\n\n The structure can be freed with rte_kvargs_free().\n\n @param args\n   The input string containing the key/value associations\n @param valid_keys\n   A list of valid keys (table of const char *, the last must be NULL).\n   This argument is ignored if NULL\n\n @return\n   - A pointer to an allocated rte_kvargs structure on success\n   - NULL on error"]
    pub fn rte_kvargs_parse(
        args: *const ::std::os::raw::c_char,
        valid_keys: *const *const ::std::os::raw::c_char,
    ) -> *mut rte_kvargs;
}
extern "C" {
    #[doc = " Allocate a rte_kvargs and store key/value associations from a string.\n This version will consider any byte from valid_ends as a possible\n terminating character, and will not parse beyond any of their occurrence.\n\n The function allocates and fills an rte_kvargs structure from a given\n string whose format is key1=value1,key2=value2,...\n\n The structure can be freed with rte_kvargs_free().\n\n @param args\n   The input string containing the key/value associations\n\n @param valid_keys\n   A list of valid keys (table of const char *, the last must be NULL).\n   This argument is ignored if NULL\n\n @param valid_ends\n   Acceptable terminating characters.\n   If NULL, the behavior is the same as ``rte_kvargs_parse``.\n\n @return\n   - A pointer to an allocated rte_kvargs structure on success\n   - NULL on error"]
    pub fn rte_kvargs_parse_delim(
        args: *const ::std::os::raw::c_char,
        valid_keys: *const *const ::std::os::raw::c_char,
        valid_ends: *const ::std::os::raw::c_char,
    ) -> *mut rte_kvargs;
}
extern "C" {
    #[doc = " Free a rte_kvargs structure\n\n Free a rte_kvargs structure previously allocated with\n rte_kvargs_parse().\n\n @param kvlist\n   The rte_kvargs structure. No error if NULL."]
    pub fn rte_kvargs_free(kvlist: *mut rte_kvargs);
}
extern "C" {
    #[doc = " Get the value associated with a given key.\n\n If multiple keys match, the value of the first one is returned.\n\n The memory returned is allocated as part of the rte_kvargs structure,\n it must never be modified.\n\n @param kvlist\n   A list of rte_kvargs pair of 'key=value'.\n @param key\n   The matching key.\n\n @return\n   NULL if no key matches the input,\n   a value associated with a matching key otherwise."]
    pub fn rte_kvargs_get(
        kvlist: *const rte_kvargs,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the value associated with a given key and value.\n\n Find the first entry in the kvlist whose key and value match the\n ones passed as argument.\n\n The memory returned is allocated as part of the rte_kvargs structure,\n it must never be modified.\n\n @param kvlist\n   A list of rte_kvargs pair of 'key=value'.\n @param key\n   The matching key. If NULL, any key will match.\n @param value\n   The matching value. If NULL, any value will match.\n\n @return\n   NULL if no key matches the input,\n   a value associated with a matching key otherwise."]
    pub fn rte_kvargs_get_with_value(
        kvlist: *const rte_kvargs,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Call a handler function for each key=value matching the key\n\n For each key=value association that matches the given key, calls the\n handler function with the for a given arg_name passing the value on the\n dictionary for that key and a given extra argument.\n\n @note Compared to @see rte_kvargs_process_opt, this API will return -1\n when handle only-key case (that is the matched key's value is NULL).\n\n @param kvlist\n   The rte_kvargs structure.\n @param key_match\n   The key on which the handler should be called, or NULL to process handler\n   on all associations\n @param handler\n   The function to call for each matching key\n @param opaque_arg\n   A pointer passed unchanged to the handler\n\n @return\n   - 0 on success\n   - Negative on error"]
    pub fn rte_kvargs_process(
        kvlist: *const rte_kvargs,
        key_match: *const ::std::os::raw::c_char,
        handler: arg_handler_t,
        opaque_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call a handler function for each key=value or only-key matching the key\n\n For each key=value or only-key association that matches the given key, calls\n the handler function with the for a given arg_name passing the value on the\n dictionary for that key and a given extra argument.\n\n @param kvlist\n   The rte_kvargs structure.\n @param key_match\n   The key on which the handler should be called, or NULL to process handler\n   on all associations\n @param handler\n   The function to call for each matching key\n @param opaque_arg\n   A pointer passed unchanged to the handler\n\n @return\n   - 0 on success\n   - Negative on error"]
    pub fn rte_kvargs_process_opt(
        kvlist: *const rte_kvargs,
        key_match: *const ::std::os::raw::c_char,
        handler: arg_handler_t,
        opaque_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Count the number of associations matching the given key\n\n @param kvlist\n   The rte_kvargs structure\n @param key_match\n   The key that should match, or NULL to count all associations\n\n @return\n   The number of entries"]
    pub fn rte_kvargs_count(
        kvlist: *const rte_kvargs,
        key_match: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
